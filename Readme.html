<!DOCTYPE html>
<html>
<head>
<title>Readme.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<p>This file contains the required information for the replication of the results in:</p>
<h1 id="risk-aversion-in-share-auctions-estimating-rents-from-trqs-in-switzerland"><strong><a href="https://dx.doi.org/10.2139/ssrn.3397027">Risk Aversion in Share Auctions: Estimating Rents from TRQs in Switzerland</a></strong></h1>
<p>Author: <a href="https://samuelhaefner.github.io">Samuel HÃ¤fner</a>, Web3 Foundation, Zug, and University of St. Gallen, <a href="mailto:samuel.haefner@gmail.com">samuel.haefner@gmail.com</a>.</p>
<p>Current version: October, 2022.</p>
<h1 id="table-of-contents">Table of Contents</h1>
<ul>
<li><a href="#data">Data</a></li>
<li><a href="#overview-of-the-replication-files">Overview of the replication files</a></li>
<li><a href="#estimation-procedure-on-a-slurm-workload-manager">Estimation Procedure on a SLURM Workload Manager</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#tables-and-plots">Tables and Plots</a></li>
<li><a href="#scripts-in-more-detail">Scripts in More Detail</a>
<ul>
<li><a href="#the-main-global-variables">The main global variables</a></li>
<li><a href="#estimationjl">Estimation.jl</a></li>
<li><a href="#testmonjl">TestMon.jl</a></li>
<li><a href="#auxiliaryjl">Auxiliary.jl</a></li>
</ul>
</li>
</ul>
<h1 id="data">Data</h1>
<p>The auction data is contained in the file <code>setofbids.csv</code>. Each row corresponds to a submitted price-quantity pair. The columns are the following:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>auction</code></td>
<td>auction id</td>
</tr>
<tr>
<td><code>quotatot</code></td>
<td>quota (in kg)</td>
</tr>
<tr>
<td><code>bid_id</code></td>
<td>bid id</td>
</tr>
<tr>
<td><code>bidder</code></td>
<td>bidder id</td>
</tr>
<tr>
<td><code>qb</code></td>
<td>quantity point (not cumulative, in kg)</td>
</tr>
<tr>
<td><code>pb</code></td>
<td>price point (in Swiss cents)</td>
</tr>
<tr>
<td><code>qr</code></td>
<td>resulting quantity (from that price-quantity pair)</td>
</tr>
<tr>
<td><code>pr</code></td>
<td>resulting payment</td>
</tr>
<tr>
<td><code>qperc</code></td>
<td>percentage of total quota</td>
</tr>
</tbody>
</table>
<h1 id="overview-of-the-replication-files">Overview of the replication files</h1>
<p>This <a href="https://github.com/SamuelHaefner/RiskAversionInShareAuctions">repository</a> contains the following items:</p>
<ol>
<li>The <em>main code</em> used for estimation. The code comes in four main files:
<ul>
<li><code>Auxiliary.jl</code> - Reads in the required packages, the data set and defines the required auxiliary functions and  global variables.</li>
<li><code>Grouping.jl</code> - Determines the bidder groups and auction groups used for the estimation.</li>
<li><code>Estimation.jl</code> - Contains the main functions for the estimation of W, $\Theta$, and the bounds.</li>
<li><code>TestMon.jl</code> - Contains the main functions to test for the monotonicity of $F^j_i$ in v.</li>
</ul>
</li>
<li>The <em>scripts to conduct the estimation</em>. In particular, the following files contain the scripts to produce the .jl and .sh files that can then be run on a SLURM workload manager.
<ul>
<li><code>EstimateWandTSLURM.jl</code> - Produces the required .jl and .sh files to compute and save estimates of W and $\Theta$.</li>
<li><code>EstimateWandTRobustSLURM.jl</code> - Produces the required files to compute and save the robustness checks for $\Theta$, using a log-normal distribution rather than a gamma distribution when estimating W.</li>
<li><code>EstimateBoundsSLURM.jl</code> - Produces the required files to compute standard and tighter bounds, using the estimates of W(p,q) obtained with EstimateWandTSLURM.jl.</li>
<li><code>TestMonSLURM.jl</code> - Produces the required files to test for monotonicity of F.</li>
</ul>
</li>
<li><em>Templates</em> used by the scripts above. Essentially, the scripts above split up the jobs into a manageable number of bootstrap rounds. To do so, they require the following generic .jl and .sh templates. For further information, see the files themselves.
<ul>
<li><code>EstimateWandTGeneric.jl</code></li>
<li><code>EstimateWandTRobustGeneric.jl</code></li>
<li><code>EstimateBoundsGeneric.jl</code></li>
<li><code>TestMonGeneric.jl</code></li>
<li><code>EstimateWandTGeneric.sh</code></li>
<li><code>EstimateWandTRobustGeneric.sh</code></li>
<li><code>EstimateBoundsGeneric.sh</code></li>
<li><code>TestMonGeneric.sh</code></li>
</ul>
</li>
<li>The scripts to <em>read and further process the estimates</em> produced with above *SLURM.jl scripts. Once the estimates are saved in the respective .dat files, these scripts can be run as they are; they will produce the required figures and data for the tables.
<ul>
<li><code>ReadEstimates.jl</code> - Scripts and functions to read in the estimates of the bounds and produce the respective tables.</li>
<li><code>ReadT.jl</code> - Scripts to read in estimates of T and produce the plots and tables.</li>
<li><code>ReadTRobust.jl</code> - Same as above, but using the alternative estimates (robustness check).</li>
<li><code>ReadTestMon.jl</code> - Contains the script to read in the monotonicity violations obtained and saved with TestMonGeneric.jl and produces the respective tables.</li>
</ul>
</li>
<li>Scripts to produce additional tables and plots.
<ul>
<li><code>DataOverviewTable.jl</code> - Script to generate the overview table of the data (Table 1).</li>
<li><code>Plots.jl</code> - Script to generate the group plots, the resampling plots, and the plot showing the estimated bounds (which is done with function <code>PlotTighterBounds()</code>; cf. the file for more information).</li>
</ul>
</li>
<li>A file called <a href="https://drive.google.com/file/d/1PlKXkPn4GbM3ImMSvveuznnPRTeeURGe/view?usp=sharing">Estimate Data.zip</a> also belongs to the replication files (externally hosted). It contains the estimates reported in the manuscript as described in Comment 3 below.</li>
</ol>
<p><em>Comment 1:</em> The script <code>TestMonWandBounds.jl</code> produces the required files containing the estimates of W(p,q) and the bounds for the monotonicity check. This script needs to be run before the TestMon*.jl scripts, using the bash script <code>TestMonWandBounds.sh</code>.</p>
<p><em>Comment 2:</em> Computation was conducted at <a href="http://scicore.unibas.ch/">sciCORE</a> (scientific computing core) facility at the University of Basel, using a SLURM workload manager. The Julia version used was 1.6. Computation time depended on the script, ranging from 2-3 hours (WandTGeneric.jl and TestMonGeneric.jl) up to 24 hours (EstimateBoundsGeneric.jl).</p>
<h1 id="estimation-procedure-on-a-slurm-workload-manager">Estimation Procedure (on a SLURM Workload Manager)</h1>
<p>The estimation was conducted at <a href="http://scicore.unibas.ch/">sciCORE</a> (scientific computing core) facility at the University of Basel, using a SLURM workload manager. This allows to run several bootstrap rounds in parallel.</p>
<p>Below, I describe the basic procedure to do so. (Further down, in the Example section, I explain how the programs can be run locally.)</p>
<ol>
<li>Upload the data file (see below) and the <em>main code</em> files (Point 1 above) to the relevant folder.</li>
<li>Run the scripts under Point 2 in Section <a href="#Overview">Overview</a> above locally. This produces a host of *.jl and *.sh files.</li>
<li>Upload these files together with <code>TestMonWandBounds.sh</code> and <code>TestMonWandBounds.jl</code> to the relevant folder and run the following main .sh files: (1) <code>EstimateWandT.sh</code>, (2) <code>EstimateWandTRobust.sh</code>, (3) <code>EstimateBounds.sh</code>, (4) <code>TestMonWandBounds.sh</code>, (5) <code>TestMon.sh</code>. Scripts (1) and (2) can be run in parallel, but they need to be completed before running (3). Script (4) needs to be run before script (5) (see Comment 1 above).</li>
<li>After the scripts completed, download the *.dat files with the estimates.</li>
<li>Run the scripts described under Point 4 in Section <a href="#Overview">Overview</a> above.</li>
</ol>
<p><em>Comment 3:</em> The estimates that I obtained and reported in the manuscript (<code>Estimate Data.zip</code>) can be downloaded <a href="https://drive.google.com/file/d/1PlKXkPn4GbM3ImMSvveuznnPRTeeURGe/view?usp=sharing">here</a>. This file contains the .dat files, so that the interested reader may directly jump to Point 5 above.</p>
<h1 id="example">Example</h1>
<p>The following code, which can be run locally, goes through the basic computations. Doing one bootstrap round, the code first estimates W(p,q), then computes $\Theta(\rho)$, and last determines the bounds for $\rho=0$ and $\rho=\rho^*$.</p>
<pre class="hljs"><code><div><span class="hljs-comment">#######################################################################</span>
<span class="hljs-comment">## load the data set. </span>
<span class="hljs-comment">## define global variables and relevant functions</span>
<span class="hljs-comment">##</span>
<span class="hljs-comment">## required packages: CSV; DataFrames; Distributions; </span>
<span class="hljs-comment">##                    BSON: @save, @load;  Roots</span>
<span class="hljs-comment">#######################################################################</span>
include(<span class="hljs-string">"Auxiliary.jl"</span>)
include(<span class="hljs-string">"Estimation.jl"</span>)
include(<span class="hljs-string">"Grouping.jl"</span>)
include(<span class="hljs-string">"TestMon.jl"</span>)

<span class="hljs-comment">#######################################################################</span>
<span class="hljs-comment">## the following lines compute the estimates of W(p,q).  </span>
<span class="hljs-comment">#######################################################################</span>

<span class="hljs-comment"># obtain the average number of active bidders for each bidder group  </span>
n = AvgNoBidders(bidderassignment)

<span class="hljs-comment"># do m=1 bootstrap round</span>
m = <span class="hljs-number">1</span>

<span class="hljs-comment"># draw P=200 opponent demand functions when resampling (cf. Algorithm 1)</span>
P = <span class="hljs-number">200</span>

<span class="hljs-comment"># W is computed for each auction group separately</span>
W = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>:<span class="hljs-number">1</span>:length(group);]  
    auctionset = group[i]
    prices = PriceBids(auctionset)
    push!(W, Wgamma(prices, auctionset, bidderassignment, n, m, P))
<span class="hljs-keyword">end</span>

<span class="hljs-comment">######################################################################</span>
<span class="hljs-comment">## The following computes all the values required </span>
<span class="hljs-comment">## to compute $\Theta_g(\rho)$ for the values in rhovec. </span>
<span class="hljs-comment">##</span>
<span class="hljs-comment">## The result is a list of the following form:</span>
<span class="hljs-comment">## Theta[auctiongroup][auction][rhovalue][totalpairs=1,violations=2],</span>
<span class="hljs-comment">## the entries of which consists of three numbers, one corresponding</span>
<span class="hljs-comment">## to each bidder group.</span>
<span class="hljs-comment">######################################################################</span>

<span class="hljs-comment"># define the vector of rho values for with \Theta_g is computed</span>
rhovec = [[exp(x),exp(x),exp(x)] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> sort!(append!([-<span class="hljs-number">10</span>:<span class="hljs-number">0.5</span>:<span class="hljs-number">0</span>;],-<span class="hljs-literal">Inf</span>))]

<span class="hljs-comment"># the values are computed for each auction </span>
<span class="hljs-comment"># in each auction group [g] separately</span>
Theta = []
<span class="hljs-keyword">for</span> g <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>:<span class="hljs-number">1</span>:length(group);]
    auctionset = group[g]
    prices = PriceBids(auctionset)
    ThetaGroup = []
    <span class="hljs-keyword">for</span> auction <span class="hljs-keyword">in</span> auctionset
        ThetaAuction = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>:<span class="hljs-number">1</span>:length(rhovec);]
            bounds = EstimateSimpleBounds(
                auction,
                W[g],
                bidderassignment,
                prices,
                rhovec[i],
                m,
            )
            push!(
                ThetaAuction,
                EstTheta(
                    auction,
                    W[g],
                    bidderassignment,
                    prices,
                    bounds,
                    rhovec[i][<span class="hljs-number">1</span>],
                    m,
                ),
            )
        <span class="hljs-keyword">end</span>
        push!(ThetaGroup, ThetaAuction)
    <span class="hljs-keyword">end</span>
    push!(Theta, ThetaGroup)
<span class="hljs-keyword">end</span>

<span class="hljs-comment">########################################################################</span>
<span class="hljs-comment">## The following code computes both the simple and the tighter bounds </span>
<span class="hljs-comment">## for rho=(0,0,0) and rho=rho^* (only the first for rho=0, and </span>
<span class="hljs-comment">## both for rho=rho*) for all active bidders in a given auction</span>
<span class="hljs-comment">##</span>
<span class="hljs-comment">## The result is a list called BoundAuctions,</span>
<span class="hljs-comment">##    BoundsAuction[1] -- List of length=77, each element corresponding to </span>
<span class="hljs-comment">##                          the simple bounds under risk neutrality of  </span>
<span class="hljs-comment">##                          an active bidder</span>
<span class="hljs-comment">##    BoundsAuction[2] -- List of length=2. The first element is a list as above</span>
<span class="hljs-comment">##                          but under risk aversion, \rho^*.</span>
<span class="hljs-comment">##                          The second element is a list containing the </span>
<span class="hljs-comment">##                          tighter bounds for each bidder under \rho^*.</span>
<span class="hljs-comment">########################################################################</span>

<span class="hljs-comment"># define the two vectors of values for rho within the three groups</span>
rhovec = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[exp(-<span class="hljs-number">5</span>),exp(-<span class="hljs-number">7</span>),exp(-<span class="hljs-number">8</span>)]]

<span class="hljs-comment"># take the third auction in the first auction group, g=2</span>
g = <span class="hljs-number">2</span>
prices = PriceBids(group[g])
auction = group[g][<span class="hljs-number">3</span>]
BoundsAuction = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>:<span class="hljs-number">1</span>:length(rhovec);]
  simplebounds = EstimateSimpleBoundsRobust(
    auction,
    W[g],
    bidderassignment,
    prices,
    rhovec[i],
    m,
  )
  <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>
    push!(BoundsAuction, simplebounds)
  <span class="hljs-keyword">else</span>
    push!(
      BoundsAuction,
      EstTighterBounds(
        auction,
        W[g],
        bidderassignment,
        prices,
        simplebounds,
        rhovec[i],
        m,
        <span class="hljs-number">10</span>,
        <span class="hljs-number">0.0001</span>,
      ),
    )
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<h1 id="tables-and-plots">Tables and Plots</h1>
<p>The following table explains which scripts are used to produce the tables and plots in the <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3397027">main paper</a>.</p>
<table>
<thead>
<tr>
<th>Figure/Table</th>
<th>Script</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>Figure 1</td>
<td>none</td>
<td>tikz-scripts in separate .tex files (available upon request)</td>
</tr>
<tr>
<td>Figure 2</td>
<td>none</td>
<td>tikz-script in separate .tex file (available upon request)</td>
</tr>
<tr>
<td>Figure 3</td>
<td><code>Plots.jl</code></td>
<td>Lines 9-34 (left panel). Lines 63-83 (right panel).</td>
</tr>
<tr>
<td>Figure 4</td>
<td><code>ReadT.jl</code></td>
<td>Lines 1-95; 190-340.</td>
</tr>
<tr>
<td>Figure 5</td>
<td><code>Plots.jl</code></td>
<td>Function <code>PlotTighterBounds()</code>; see the file for further information.</td>
</tr>
<tr>
<td>Figure B.1</td>
<td><code>Plots.jl</code></td>
<td>Lines 36-60 (left panel). Lines 63-85 (right panel).</td>
</tr>
<tr>
<td>Figure B.2</td>
<td><code>Plots.jl</code></td>
<td>Lines 154-180 (left panel). Lines 88-151 (right panel).</td>
</tr>
<tr>
<td>Figure D.1</td>
<td><code>Plots.jl</code></td>
<td>Lines 282-618.</td>
</tr>
<tr>
<td>Table 1</td>
<td><code>DataOverviewTable.jl</code></td>
<td>See file for more information.</td>
</tr>
<tr>
<td>Table 2</td>
<td><code>ReadT.jl</code></td>
<td>Lines 342-361.</td>
</tr>
<tr>
<td>Table 3</td>
<td><code>ReadEstimates.jl</code></td>
<td>See file for more information.</td>
</tr>
<tr>
<td>Table C.1</td>
<td><code>ReadTestMon.jl</code></td>
<td>See file for more information.</td>
</tr>
<tr>
<td>Table E.1</td>
<td><code>ReadEstimates.jl</code></td>
<td>See file for more information.</td>
</tr>
</tbody>
</table>
<p>The following table explains which scripts are used to produce the tables and plots in the <a href="https://samuelhaefner.github.io/SupplementaryAppendix.pdf">supplementary appendix</a> of the paper.</p>
<table>
<thead>
<tr>
<th>Figure/Table</th>
<th>Script</th>
<th>Line Number</th>
</tr>
</thead>
<tbody>
<tr>
<td>Figure B.1</td>
<td><code>ReadT.jl</code></td>
<td>Lines 1-95; 364-789.</td>
</tr>
<tr>
<td>Figure C.1</td>
<td><code>ReatT.jl</code> (left figure) and <code>ReadTRobust.jl</code> (right figure)</td>
<td>See files for more information.</td>
</tr>
<tr>
<td>Table B.1</td>
<td><code>ReadT.jl</code></td>
<td>Lines 1-95; 364-789.</td>
</tr>
<tr>
<td>Table C.1</td>
<td><code>ReatT.jl</code> (right table) and <code>ReadTRobust.jl</code> (left table)</td>
<td>See files for more information.</td>
</tr>
<tr>
<td>Tables in Section D</td>
<td><code>ReadEstimates.jl</code></td>
<td>See files for more information.</td>
</tr>
</tbody>
</table>
<h1 id="scripts-in-more-detail">Scripts in More Detail</h1>
<p>This section provides the details about the functions and global variables defined in the four main files.</p>
<h2 id="the-main-global-variables">The main global variables</h2>
<p>The <strong>main global variables</strong> used throughout the replication files are defined in the file <code>Auxiliary.jl</code> and are the followoing.</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bids</code></td>
<td>a data frame containing the bidding data</td>
</tr>
<tr>
<td><code>K</code></td>
<td>max number of price-quantity pairs</td>
</tr>
<tr>
<td><code>un</code></td>
<td>unit of account (100 corresponds to CHF/kg)</td>
</tr>
<tr>
<td><code>vupperbar</code></td>
<td>upper bound on type space (in CHF)</td>
</tr>
<tr>
<td><code>auctionindeces</code></td>
<td>vector containing the auctionindeces corresponding to those in the data</td>
</tr>
<tr>
<td><code>bidderindeces</code></td>
<td>vector containing the bidderindeces corresponding to those in the data</td>
</tr>
<tr>
<td><code>quotas</code></td>
<td>vector with the quotas</td>
</tr>
<tr>
<td><code>clearingprices</code></td>
<td>vector with the market clearing prices</td>
</tr>
<tr>
<td><code>activebidders</code></td>
<td>vector with the number of active bidders</td>
</tr>
<tr>
<td><code>activebidderindeces</code></td>
<td>list of vectors with the indeces of the active bidders</td>
</tr>
</tbody>
</table>
<p>In the file <code>Grouping.jl</code> the following, <strong>additional global variables</strong> used for the estimation of W are defined:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>group</code></td>
<td>list containing, for each auction group, a vector of the respective auction indeces</td>
</tr>
<tr>
<td><code>bidderassignment</code></td>
<td>a vector determining for every bidder the bidder group assignment {1,2,3}</td>
</tr>
</tbody>
</table>
<p>In the following subsections, I discuss the functions defined in the respective files <code>Estimation.jl</code>, <code>TestMon.jl</code>, and <code>Auxiliary.jl</code>.</p>
<h2 id="estimationjl">Estimation.jl</h2>
<pre class="hljs"><code><div>Wgamma(prices, auctionset, bidderassignment, n, m, P) 
</div></code></pre>
<h4 id="description">Description</h4>
<p>Estimates $W(p,q)$ using a gamma distribution.</p>
<h4 id="arguments">Arguments</h4>
<p><code>prices</code> -- vector of submitted prices to be used for the estimation of $W$.<br>
<code>auctionset</code> -- vector with indeces of auctions to be used for the estimation of $W$.<br>
<code>bidderassignment</code> -- bidder assignment vector<br>
<code>n</code> -- vector, each entry corresponding to the (average) number of active bidders from a given group<br>
<code>m</code> -- number of bootstrap rounds to be estimated<br>
<code>P</code> -- number of rounds of resampling used for estimation</p>
<h4 id="return-value">Return value</h4>
<p>A list of parameter estimates for the distribution of $W(p,q)$. For each group in <code>bidderassignment</code>, each bootstrap round, and each price in the vector <code>prices</code>.</p>
<hr>
<pre class="hljs"><code><div>Wlnorm(prices, auctionset, bidderassignment, n, m, P)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Same as <code>Wgamma()</code>, yet using a log normal distribution.</p>
<hr>
<pre class="hljs"><code><div>SimpleBound(bid, WPar, rho, Q)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Computes upper and lower bounds on the rationalizable profit functions as described in Proposition 3 and equations (9)-(10).</p>
<h4 id="arguments">Arguments</h4>
<p><code>bid</code> -- bid function<br>
<code>WPar</code> -- array, containing the estimated parameters of W(p,q) at (p_i^j) for steps j=1,...,k<br>
<code>rho</code> -- positive real number, corresponding to the risk preference $\rho$<br>
<code>Q</code> -- positive real number, corresponding to the quota $Q$</p>
<h4 id="return-value">Return value</h4>
<p>A list of dataframes, [vlb,vub], where vub is the data frame containing the upper bound and vlb is the data frame containing lower bound.</p>
<hr>
<pre class="hljs"><code><div>SimpleBoundRobust(bid, WPar, rho, Q)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Computes upper and lower bounds on the rationalizable profit
functions as described in Proposition 3.
If the bounds violated the inequalities (15) in Proposition 4,
return <code>upper bound = vupperbar</code> and <code>lower bound = bid</code>.</p>
<h4 id="arguments">Arguments</h4>
<p><code>bid</code> -- bid function<br>
<code>WPar</code> -- array, containing the estimated parameters of $W(p,q)$ at $p_i^j$ for steps j=1,...,k<br>
<code>rho</code> -- positive real number, corresponding to the risk preference $\rho$<br>
<code>Q</code> -- positive real number, corresponding to the quota $Q$</p>
<h4 id="return-value">Return value</h4>
<p>Return a list of dataframes, [vlb,vub],
where vub is the data frame containing the upper bound
and vlb is the data frame containing lower bound.</p>
<hr>
<pre class="hljs"><code><div>EstimateSimpleBounds(auction, W, bidderassignment,  prices, rhovec, m)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Computes <code>SimpleBounds()</code> for all bidders in <code>auction</code>.</p>
<h4 id="arguments">Arguments</h4>
<p><code>auction</code> -- auction index<br>
<code>W</code> -- estimate of $W$, as returned from <code>Wgamma()</code> or <code>Wlnorm()</code><br>
<code>bidderassignment</code> -- bidder assignment vector<br>
<code>prices</code> -- vector of submitted prices used for the estimation of $W$<br>
<code>rhovec</code> -- vector of positive real number, each number corresponding to the risk preference $\rho_g$ in bidder group $g$<br>
<code>m</code> -- number of bootstrap rounds to be estimated</p>
<h4 id="return-value">Return value</h4>
<p>A list of objects returned by <code>SimpleBounds()</code>, one entry per bidder.</p>
<hr>
<pre class="hljs"><code><div>EstimateSimpleBoundsRobust(auction, W, bidderassignment,  prices, rhovec, m)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Computes <code>SimpleBoundsRobust()</code> for all bidders in <code>auction</code>.</p>
<h4 id="arguments">Arguments</h4>
<p><code>auction</code> -- auction index<br>
<code>W</code> -- estimate of $W$, as returned from <code>Wgamma()</code> or <code>Wlnorm()</code><br>
<code>bidderassignment</code> -- bidder assignment vector<br>
<code>prices</code> -- vector of submitted prices used for the estimation of $W$<br>
<code>rhovec</code> -- vector of positive real number, each number corresponding to the risk preference $\rho_g$ in bidder group $g$<br>
<code>m</code> -- number of bootstrap rounds to be estimated</p>
<h4 id="return-value">Return value</h4>
<p>A list of objects returned by <code>SimpleBoundRobust()</code>, one entry per bidder.</p>
<hr>
<pre class="hljs"><code><div>EstTheta(auction, W, bidderassignment, prices, bounds, rho, m)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determines violations of the inequalities in Proposition 4 for a given auction.</p>
<h4 id="arguments">Arguments</h4>
<p><code>auction</code> -- auction index<br>
<code>W</code> -- estimate of W, as returned from <code>Wgamma()</code> or <code>Wlnorm()</code><br>
<code>bidderassignment</code> -- bidder assignment vector<br>
<code>prices</code> -- vector of prices used for the estimation of W<br>
<code>bounds</code> -- estimated simple bounds from <code>EstimateSimpleBounds()</code><br>
<code>rho</code> -- positive real number, the risk preference<br>
<code>m</code> -- number of bootstrap rounds</p>
<h4 id="return-value">Return value</h4>
<p>A list of three matrices, with the columns corresponding to bootstrap rounds and rows corresponding to bidder groups. The first matrix counts the number of violations of the inequalities (15) in Prop. 4, the second matrix counts the number of violations of the inequalities (16) in Prop. 4, and the third matrix counts the total number of submitted price-quantity pairs.</p>
<hr>
<pre class="hljs"><code><div>TighterBounds(bid, initvl, initvu, W, g, prices, rho, Q, bootstraprun, maxiter, tolerance)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Computes tighter upper and lower bounds from initial conditions <code>initvl</code> and <code>initivu</code> by runing Algorithm 2.</p>
<h4 id="arguments">Arguments</h4>
<p><code>bid</code> -- bid function<br>
<code>initvl</code> -- marginal profit function, the initial condition for the lower bound<br>
<code>initvu</code> -- marginal profit function, the initial condition for the upper bound<br>
<code>W</code> -- estimate of W, as returned from <code>Wgamma()</code> or <code>Wlnorm()</code><br>
<code>g</code> -- natural number, indicating the group number of the auction<br>
<code>prices</code> -- vector of prices used for the estimation of W<br>
<code>rho</code> -- positive real number, the risk preference<br>
<code>bootstraprun</code> -- index of boostratp run we look at<br>
<code>maxiter</code> -- maximum number of fixed point iterations<br>
<code>tolerance</code> -- tolerance level (used in iteration)</p>
<h4 id="return-value">Return value</h4>
<p>A list of dataframes, [vlb,vub], where vub is the data frame containing the upper bound and vlb is the data frame containing lower bound.</p>
<hr>
<pre class="hljs"><code><div>EstTighterBounds(auction, W, bidderassignment, prices, bounds, rhovec, m, maxiter, tolerance)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Runs <code>TighterBounds()</code> for all bidders in an <code>auction</code> and for <code>m</code> bootstrap rounds.</p>
<h4 id="arguments">Arguments</h4>
<p><code>auction</code> -- auction index<br>
<code>W</code> -- estimate of W, as returned from <code>Wgamma()</code> or  <code>Wlnorm()</code><br>
<code>bidderassignment</code> -- bidder assignment vector<br>
<code>prices</code> -- vector of prices used for the estimation of <code>W</code><br>
<code>bounds</code> -- estimated simple bounds from <code>EstimateSimpleBoundsRobust()</code><br>
<code>rhovec</code> -- vector of positive real number, each number corresponding to the risk preference $\rho_g$ in bidder group $g$<br>
<code>m</code> -- number of boostratp runs<br>
<code>maxiter</code> -- maximum number of fixed point iterations<br>
<code>tolerance</code> -- tolerance level (used in iteration)</p>
<h4 id="return-value">Return value</h4>
<p>List containing for each bidder and each bootstrap round a two dimensional list [<code>bounds</code>,<code>tighterbounds</code>], where <code>tighterbounds</code> is the object returned by <code>TighterBounds()</code>.</p>
<h2 id="testmonjl">TestMon.jl</h2>
<pre class="hljs"><code><div>TestIncreasingDiff(auction, bidderset, BoundsAuction, W, R, rhoindexset, rhovec)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determines the number of price-quantity pairs for which the monotonicity assumption on $F^j$ is violated for a given auction.</p>
<h4 id="arguments">Arguments</h4>
<p><code>auction</code> -- auction index<br>
<code>bidderset</code> -- bidder index set (set of bidders to be looked at)<br>
<code>BoundsAuction</code> -- first element in list returned by <code>LoadWandBounds()</code><br>
<code>W</code> -- second element in list returned by <code>LoadWandBounds()</code><br>
<code>R</code> -- number of tests per bid step<br>
<code>rhoindexset</code> -- vector of indexes, referring to rhovec, for which the test is run<br>
<code>rhovec</code> -- vector of rho values</p>
<h4 id="return-value">Return value</h4>
<p>A list of length of the <code>rhoindexset</code>, each entry is again a list of length of the <code>bidderset</code>, and each entry of that list consists of two numbers: (1) the total number of price-quantity pairs tested for that bidder (2) the total number of price-quantity pairs for which a violation of monotonicity was found.</p>
<hr>
<pre class="hljs"><code><div>GetQVals(g, bidstep)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Draws a random number (uniformly between 1 and 20) of equidistant x-values that lie between the x-values of the <code>bidstep</code>-th price-quantity pair and the (<code>bidstep</code>-1)-th price-quantity pair in <code>g</code>.</p>
<h4 id="arguments">Arguments</h4>
<p><code>g</code> -- decreasing step function function with a number of steps of at least <em>bidstep</em><br>
<code>bidstep</code> -- natural number, indicating the number of the step in the bid function</p>
<h4 id="return-value">Return value</h4>
<p>List of x-values.</p>
<hr>
<pre class="hljs"><code><div>GetHigherF(g, h, qval)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Compute a random step function between <code>g</code> and <code>h</code> with x values given in <code>qval</code></p>
<h4 id="arguments">Arguments</h4>
<p><code>g</code>, <code>h</code> -- decreasing step function, satisfying <code>g</code> &gt; <code>h</code><br>
<code>qvals</code> -- x-values returned by <code>GetQVals()</code></p>
<h4 id="return-value">Return value</h4>
<p>Data frame containing the step function, [vval,qval].</p>
<hr>
<pre class="hljs"><code><div>CheckFOCMonotone(bidstep, bid, vub, vlb, W, g, prices, rho, Q, bootstraprun, R)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Evaluates $F^j$ at the two different, ordered profit functions <code>R</code> times and reports the differences.</p>
<h4 id="arguments">Arguments</h4>
<p><code>bidstep</code> -- natural number, the bid step to be looked at<br>
<code>bid</code> -- bid function<br>
<code>vub</code> -- marginal profit function, (simple) upper bound<br>
<code>vlb</code> -- marginal profit function, (simple) lower bound<br>
<code>W</code> -- estimate of W as obtained by <code>Wgamma()</code> or <code>Wlnorm()</code>
<code>g</code> -- natural number, indicating the group number of the auction<br>
<code>prices</code> -- vector of prices used for the estimation of W<br>
<code>rho</code> -- real number, risk preference $\rho$<br>
<code>Q</code> -- real number, the quota $Q$<br>
<code>bootstraprun</code> -- the number of the bootrap round<br>
<code>R</code> -- the number of tests per bid step</p>
<h4 id="return-value">Return value</h4>
<p>List of length <code>R</code>, containing the differences.</p>
<hr>
<pre class="hljs"><code><div>LoadWandBounds(auction)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Loads estimates of W and of simple bounds for <code>auction</code> from corresponding .dat files.</p>
<h4 id="arguments">Arguments</h4>
<p><code>auction</code> -- auction index</p>
<h4 id="return-value">Return value</h4>
<p>List containing W and simple bounds for <code>auction</code></p>
<hr>
<pre class="hljs"><code><div>TestIncreasingDiffBidder(auction, bidder, Bounds, W, R, rho)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determines for a bidder in a given auction whether monotonicity of $F^j$ is violated for the submitted price-quantity pairs.</p>
<h4 id="arguments">Arguments</h4>
<p><code>auction</code> -- auction index<br>
<code>bidder</code> -- bidder index<br>
<code>Bounds</code> -- first element in list returned by <code>LoadWandBounds(</code>)<br>
<code>W</code> -- second element in list returned by <code>LoadWandBounds()</code><br>
<code>R</code> -- number of tests per bid step<br>
<code>rho</code> -- real number, risk preference $\rho$</p>
<h4 id="return-value">Return value</h4>
<p>Two-dimensional list, [number of tests performed (corresponds to the number of bid steps), number of violations]</p>
<h2 id="auxiliaryjl">Auxiliary.jl</h2>
<pre class="hljs"><code><div>qpBid(bidder, auction)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Retrieve the bid function of a bidder in an auction.</p>
<h4 id="arguments">Arguments</h4>
<p><code>bidder</code> -- bidderindex<br>
<code>auction</code> -- auctionindex</p>
<h4 id="return-value">Return value</h4>
<p>A data frame: [qb (quantity points), pb (price points), cumqb (cumulated quantity points)].</p>
<hr>
<pre class="hljs"><code><div>AvgNoBidders(bidderassignment)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determine the average number of bidders in each bidder cluster</p>
<h4 id="arguments">Arguments</h4>
<p><code>bidderassignment</code> -- vector, each element corresponding to a bidder, denoting the cluster number of the respective bidder</p>
<h4 id="return-value">Return value</h4>
<p>A list of real numbers; one for each cluster number; returning the average no. of bidders.</p>
<hr>
<pre class="hljs"><code><div>BidToCover(auction)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determines the bid-to-cover ratio in an auction.</p>
<h4 id="arguments">Arguments</h4>
<p><code>auction</code> -- auctionindex</p>
<h4 id="return-value">Return value</h4>
<p>Real number; corresponding to the bid-to-cover ratio.</p>
<hr>
<pre class="hljs"><code><div>Revenue(auction)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determines the revenue from an auction.</p>
<h4 id="arguments">Arguments</h4>
<p><code>auction</code> -- auctionindex</p>
<h4 id="return-value">Return value</h4>
<p>Real number; corresponding to the auction revenue.</p>
<hr>
<pre class="hljs"><code><div>qRec(bidder, auction)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determines the allocated quantity of a bidder in a given auction.</p>
<h4 id="arguments">Arguments</h4>
<p><code>bidder</code> -- bidderindex<br>
<code>auction</code> -- auctionindex</p>
<h4 id="return-value">Return value</h4>
<p>Real number; corresponding to the allocated quantity.</p>
<hr>
<pre class="hljs"><code><div>qShareRec(bidder, auction)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determines the share of quota that is allocated to a bidder in a given auction.</p>
<h4 id="arguments">Arguments</h4>
<p><code>bidder</code> -- bidderindex<br>
<code>auction</code> -- auctionindex</p>
<h4 id="return-value">Return value</h4>
<p>Real number; corresponding to the received share.</p>
<hr>
<pre class="hljs"><code><div>ActiveAuctions(bidder)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determines the indeces of the auctions in which a bidder is active.</p>
<h4 id="arguments">Arguments</h4>
<p><code>bidder</code> -- bidderindex</p>
<h4 id="return-value">Return value</h4>
<p>A list of integers; corresponding to the indices of the auctions in which the bidder was active.</p>
<hr>
<pre class="hljs"><code><div>AvgBid(bidder)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determines the average bid of a bidder across the auctions in which that bidder was active.</p>
<h4 id="arguments">Arguments</h4>
<p><code>bidder</code> -- bidderindex</p>
<h4 id="return-value">Return value</h4>
<p>Real number; corresponding to the average bid of the bidder.</p>
<hr>
<pre class="hljs"><code><div>ShareSuccBidders(auction)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determines the  share of succesfull bidders (with non-zero allocated quantity) in an auction.</p>
<h4 id="arguments">Arguments</h4>
<p><code>auction</code> -- auctionindex</p>
<h4 id="return-value">Return value</h4>
<p>Real number; corresponding to the share of successful bidders.</p>
<hr>
<pre class="hljs"><code><div>SuccessRate(bidder)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Returns the success rate of a bidder (succesfull participation/total participation).</p>
<h4 id="arguments">Arguments</h4>
<p><code>bidder</code> -- bidderindex</p>
<h4 id="return-value">Return value</h4>
<p>Real number; corresponding to the bidder's success rate.</p>
<hr>
<pre class="hljs"><code><div>StepBid(q, bid)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determines the value of $\beta_b(q)$ (cf. the manuscript for a definition).</p>
<h4 id="arguments">Arguments</h4>
<p><code>q</code> -- positive real number
<code>bid</code> -- bid function as returned from qpBid(bidder, auction)</p>
<h4 id="return-value">Return value</h4>
<p>Real number; value of $\beta_{bid}(q)$.</p>
<hr>
<pre class="hljs"><code><div>NoStepBid(q, bid)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determines the step of the step function $\beta_b$ at <code>q</code>. That is, returns the number of downward jumps that have occured strictly before <code>q</code>, plus one.</p>
<h4 id="arguments">Arguments</h4>
<p><code>q</code> positive real number
<code>bid</code> bid function as returned from qpBid(bidder, auction)</p>
<h4 id="return-value">Return value</h4>
<p>Integer; see description.</p>
<hr>
<pre class="hljs"><code><div>StepV(q, v)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Returns the value of the profit function v(q).</p>
<h4 id="arguments">Arguments</h4>
<p><code>q</code> -- positive real number<br>
<code>v</code> -- marginal profit function, which is a data frame with columns <code>qval</code> (quantities, need to be increasing) and <code>vval</code> (the values of v)</p>
<h4 id="return-value">Return value</h4>
<p>Real number; corresponding to the value of the profit function v(q).</p>
<hr>
<pre class="hljs"><code><div>IntBid(a, b, bid)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Returns the value of $\int_a^b\beta_{bid}(q)dq$.</p>
<h4 id="arguments">Arguments</h4>
<p><code>a</code>, <code>b</code> -- positive real numbers
<code>bid</code> -- bid function as returned from qpBid(bidder, auction)</p>
<h4 id="return-value">Return value</h4>
<p>Real number; value of $\int_a^b\beta_{bid}(q)dq$.</p>
<hr>
<pre class="hljs"><code><div>IntV(a, b, v)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Returns the value of $\int_a^b v(q)dq$.</p>
<h4 id="arguments">Arguments</h4>
<p><code>a</code>, <code>b</code> -- positive real numbers<br>
<code>v</code> -- marginal profit function</p>
<h4 id="return-value">Return value</h4>
<p>Real number; value of $\int_a^b v(q)dq$.</p>
<hr>
<pre class="hljs"><code><div>PiOverline(bidstep, bid, v, WPar, rho, Q, n)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Returns the value of $\overline{\Pi}_i^j(b,v)$ (cf. the manuscript for a definition).</p>
<h4 id="arguments">Arguments</h4>
<p><code>bidstep</code> -- positive natural number, corresponding to the number of the step under consideration, $j$<br>
<code>bid</code> -- bid function<br>
<code>v</code> -- marginal profit function<br>
<code>WPar</code> -- array, containing the estimated parameters of the distribution of $D(p_i^j)$ for steps $j=1,...,k$<br>
<code>rho</code> -- positive real number, corresponding to the risk preference $\rho$<br>
<code>Q</code> -- positive real number, corresponding to the quota $Q$<br>
<code>n</code> -- positive natural number, indicating the number of support points used for integration</p>
<h4 id="return-value">Return value</h4>
<p>Real number.</p>
<hr>
<pre class="hljs"><code><div>w(q, WPar, dp)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Computes $w_i(p,q)$.</p>
<h4 id="arguments">Arguments</h4>
<p><code>q</code> -- positive real number<br>
<code>WPar</code> -- array, containing two sets of estimated parameters of the distribution of $D(p)$; one for $p_i^j$ and one for $p_i^j + dp$.<br>
<code>dp</code> -- positive real number</p>
<h4 id="return-value">Return value</h4>
<p>Real number; value of $w_i(p,q)$.</p>
<hr>
<pre class="hljs"><code><div>PriceBids(auctionset)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Returns all submitted prices in <code>auctionset</code> in ascending order.</p>
<h4 id="arguments">Arguments</h4>
<p><code>auctionset</code> -- vector, containing auction indeces</p>
<h4 id="return-value">Return value</h4>
<p>List of real numbers; prices submitted in the auctions in <code>auctionset</code>.</p>
<hr>
<pre class="hljs"><code><div>FOC(bidstep, bid, v, W, group, prices, rho, Q, bootstraprun, n)
</div></code></pre>
<h4 id="description">Description</h4>
<p><code>FOC()</code> returns the value of $F^j$ (cf. the manuscript).</p>
<h4 id="arguments">Arguments</h4>
<p><code>bidstep</code> -- positive natural number, corresponding to the number of the step under consideration, j<br>
<code>bid</code> -- bid function<br>
<code>v</code> -- marginal profit function<br>
<code>W</code> -- estimates of W as returned from <code>Wgamma()</code> or <code>Wlnorm()</code><br>
<code>group</code> -- natural number, indicating the group number of the auction<br>
<code>prices</code> -- vector of submitted prices used for the estimation of $W$<br>
<code>rho</code> -- positive real number, corresponding to the risk preference $\rho$<br>
<code>Q</code> -- positive real number, corresponding to the quota $Q$<br>
<code>bootstraprun</code> -- natural number, indicating the boostrap run number<br>
<code>n</code> -- positive natural number, indicating the number of support points used for integration</p>
<h4 id="return-value">Return value</h4>
<p>Real number; value of $F^j$.</p>
<hr>
<pre class="hljs"><code><div>VarPhiU(q, v, vl)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determines $\varphi_u(q,v,v_l)$ (cf. the manuscript).</p>
<h4 id="arguments">Arguments</h4>
<p><code>q</code> -- positive real number<br>
<code>v</code> -- marginal profit function<br>
<code>vl</code> -- positive real number, corresponding to $v_l$</p>
<h4 id="return-value">Return value</h4>
<p>Real number; value of $\varphi_u(q,v,v_l)$.</p>
<hr>
<pre class="hljs"><code><div>VarPhiL(q, v, vu)
</div></code></pre>
<h4 id="description">Description</h4>
<p>Determines $\varphi_l(q,v,v_u)$ (cf. the manuscript).</p>
<h4 id="arguments">Arguments</h4>
<p><code>q</code> -- positive real number<br>
<code>v</code> -- marginal profit function<br>
<code>vu</code> -- positive real number, corresponding to $v_u$</p>
<h4 id="return-value">Return value</h4>
<p>Real number; value of $\varphi_l(q,v,v_u)$.</p>

</body>
</html>
